## Notebook01b

### Setup

Run all of the following before starting the notebook.

```{python}
#| tags: [noclear]
#| eval: false
! wget -q -nc https://raw.githubusercontent.com/taylor-arnold/fds-py/refs/heads/main/funs.py
```

```{python}
#| tags: [noclear]
import numpy as np
import polars as pl

from funs import *
from plotnine import *
from polars import col as c
theme_set(theme_minimal())

ub = "https://raw.githubusercontent.com/taylor-arnold/fds-py-nb/refs/heads/main/"
```

```{python}
#| tags: [remove]
#| include: false
ub = ""
```

```{python}
#| tags: [noclear]
food = pl.read_csv(ub + "data/food.csv").drop(c.description)
```

### Questions

Let's look at the `food` dataset that we loaded above. To get an idea about its structure, write the name of the dataset in the block below and run the cell with nothing else. This will show the column names and data types along with the first five and last five rows.

```{python}
food
```

What kinds of information in this dataset are stored as numbers?
**Answer**: All of the nutritional data is stored as numbers (calories, total_fat, sat_fat, cholesterol, sodium, carbs, fiber, sugar, protein, iron, vitamin_a, vitamin_c).

What variables in this dataset are stored as strings?
**Answer**: The food name (`item`), the food group, a string called `wiki`, and a color.

How many observations are there in the dataset?
**Answer**: There are 61 observations. We can see that in the shape parameter printed out above the DataFrame.

Can you figure out how the rows of the data are ordered?
**Answer**: Based on the first and last rows, it appears to be alphabetically by the food item name (starts with Apple and three other A's, then Banana and Chickpea, ending with Yogurt).

Throughout this book, we will want to apply data manipulation, visualization, and modeling functions to data. Whenever possible, which is most of the time, we will write these are *method chains* in a very specific format. The first line of a code block starts with an opening parenthesis and the final line has the closing parenthesis. Inside, each of the steps of the analysis will get placed with four leading spaces (you should be able to hit tab in Colab to get this), with one step on each line. The dataset goes on its own line.

In the code below, greate a method chain that starts with `food` (on its own line), applies the method `.head(10)` to grab the first ten rows, and the applies the method `.tail(3)` to grab the last three rows the remaining data. Hint: The code should have five total lines.

```{python}
(
    food
    .head(10)
    .tail(3)
)
```

What rows, relatively to the original dataset, are returned by the sequence of steps above?
**Answer**: We have the 8th, 9th, and 10th rows from the original dataset. This comes from first taking off the first 10 rows with `head` and then grabbing the last 3 rows of the result with `tail`.

Note that method chains never modify the original dataset. After running the code above `food` still has all of the original data and the new version you printed out is no longer available. If we want to save a copy of the output, we need to add something like `new_name =` before the paranthesis on the first line of the code. When we do this, the original dataset will remain but we have a copy in the `new_name` object. In the code below, repeat the steps we did above with `food` but create a new object `food_sub` that consists of the subset of three rows.

```{python}
food_sub = (
    food
    .head(10)
    .tail(3)
)
```

Notice that we do not get to see the output of the operation above. Python does not print out the result because we saved it as a new variable. To see the result, we would need to write the name of the dataset as an extra row in the code block all on its own. This, for example, is how we printed the `food` dataset in the first question above. Do this below, recreating the `food_sub` and then including the name `food_sub` on its own line to see the data.

```{python}
food_sub = (
    food
    .head(10)
    .tail(3)
)
food_sub
```

In these notebooks, please only save the output with a new object name if specifically instructed to do so. When asked to create a new object, include the object name as an extra line at the end so that we can also see and understand the results.
