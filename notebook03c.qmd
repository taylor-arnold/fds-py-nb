## Notebook03c

### Setup

Run all of the following before starting the notebook.

```{python}
#| tags: [noclear]
#| eval: false
! wget -q -nc https://raw.githubusercontent.com/taylor-arnold/fds-py/refs/heads/main/funs.py
```

```{python}
#| tags: [noclear]
import numpy as np
import polars as pl

from funs import *
from plotnine import *
from polars import col as c
theme_set(theme_minimal())

ub = "https://raw.githubusercontent.com/taylor-arnold/fds-py-nb/refs/heads/main/"
```

```{python}
#| tags: [remove]
#| include: false
ub = ""
```

```{python}
#| tags: [noclear]
movie = pl.read_csv("data/movies_50_years.csv")
```

### Questions

In this notebook, we will explore data visualization techniques using a dataset of popular movies from the past 50 years. The `movie` dataset includes information about each film's runtime (in minutes), release year, MPA rating (G, PG, PG-13, R), IMDB rating, and the number of ratings it received.

Start by creating a histogram of movie runtimes.

```{python}
(
    movie
    .pipe(ggplot, aes("runtime"))
    + geom_histogram(fill="white", color="black")
)
```

The default bin settings make it hard to interpret. Modify your histogram to use a bin width of 10 minutes, with bins starting at 0.

```{python}
(
    movie
    .pipe(ggplot, aes("runtime"))
    + geom_histogram(fill="white", color="black", binwidth=10, boundary=0)
)
```

There are some extremely long films in the dataset. Filter to keep only movies shorter than 3 hours, convert the runtime to hours, and create a histogram with 15-minute bins (that's 0.25 hours).

```{python}
(
    movie
    .filter(c.runtime < 3 * 60)
    .with_columns(
        runtime_hours = c.runtime / 60
    )
    .pipe(ggplot, aes("runtime_hours"))
    + geom_histogram(fill="white", color="black", binwidth=0.25, boundary=0)
)
```

Within a 15-minute bucket, what is the most popular duration for a film in this dataset?

**Answer** It's 1h30m to 1h45m. A fairly typical time for movies of all genres across the past fifty years.

Create a boxplot showing the distribution of runtimes for each MPA rating category.

```{python}
(
    movie
    .pipe(ggplot, aes("mpa", "runtime"))
    + geom_boxplot()
)
```

Let's see how runtimes have changed over time. Filter to movies under 3 hours, create a column for the 5-year period each movie belongs to, and make a boxplot of runtime by period. Use `factor()` around the period variable so that it is treated as a categorical variable. Hint: The 5-year period can be done the same way we did for decades, but now with 5 replacing 10 in the integer division.

```{python}
(
    movie
    .filter(c.runtime < 3 * 60)
    .with_columns(
        period = c.year // 5 * 5
    )
    .pipe(ggplot, aes("factor(period)", "runtime"))
    + geom_boxplot()
)
```

Now let's look at how audience engagement has changed. Group the data by 5-year periods and compute the average number of ratings per movie in each period. Create a scatter plot of this trend and add a linear trend line.

```{python}
(
    movie
    .with_columns(
        period = c.year // 5 * 5
    )
    .group_by(c.period)
    .agg(
        rating_count_mean = c.rating_count.mean()
    )
    .pipe(ggplot, aes("period", "rating_count_mean"))
    + geom_point()
    + geom_smooth(method="lm", se=False)
)
```

Filter to just movies from 2010 and create a scatter plot with the number of ratings on the x-axis and the IMDB rating on the y-axis. Color the points by MPA rating using the color-blind friendly color scale.

```{python}
(
    movie
    .filter(c.year == 2010)
    .pipe(ggplot, aes("rating_count", "rating"))
    + geom_point(aes(color="mpa"))
    + scale_color_cmap_d()
)
```

The rating counts span a huge range, making most points cluster on the left. Modify the previous plot to use a logarithmic scale on the x-axis so we can better see the full distribution.

```{python}
(
    movie
    .filter(c.year == 2010)
    .pipe(ggplot, aes("rating_count", "rating"))
    + geom_point(aes(color="mpa"))
    + scale_color_cmap_d()
    + scale_x_log10()
)
```

