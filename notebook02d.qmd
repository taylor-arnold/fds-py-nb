## Notebook02d

### Setup

Run all of the following before starting the notebook.

```{python}
#| tags: [noclear]
#| eval: false
! wget -q -nc https://raw.githubusercontent.com/taylor-arnold/fds-py/refs/heads/main/funs.py
```

```{python}
#| tags: [noclear]
import numpy as np
import polars as pl

from funs import *
from plotnine import *
from polars import col as c
theme_set(theme_minimal())

ub = "https://raw.githubusercontent.com/taylor-arnold/fds-py-nb/refs/heads/main/"
```

```{python}
#| tags: [remove]
#| include: false
ub = ""
```

```{python}
#| tags: [noclear]
metro = pl.read_csv(ub + "data/acs_cbsa.csv")
```

### Questions

This notebook is a review of the data manipulation techniques we have learned so far. We will work with the `metro` dataset, which contains information about US metropolitan areas from the American Community Survey. The dataset includes variables such as population (in millions), population density, median age, median household income, home ownership rates, median rent for a one-bedroom apartment, and geographic information including which census division each metro area belongs to.

Sort the metropolitan areas by population, with the largest metros at the top.

```{python}
(
    metro
    .sort(c.pop, descending=True)
)
```

Find the metro area with the highest median household income.

```{python}
(
    metro
    .sort(c.hh_income_median, descending=True)
    .head(1)
)
```

Sort the data by median age, with the youngest metros first. Which places have the youngest populations?

```{python}
(
    metro
    .sort(c.age_median)
)
```

Select only the metropolitan areas located in the South (where the quad column equals "S").

```{python}
(
    metro
    .filter(c.quad == "S")
)
```

Select metros that have a population density greater than 500 people per square mile.

```{python}
(
    metro
    .filter(c.density > 500)
)
```

Find all metros where residents spend more than 30 percent of their income on rent.

```{python}
(
    metro
    .filter(c.rent_perc_income > 30)
)
```

Select metros that are in either the Pacific or New England divisions.

```{python}
(
    metro
    .filter(c.division.is_in(["Pacific", "New England"]))
)
```

Find metros in the South that have a median household income above $80,000. Use two separate filter steps.

```{python}
(
    metro
    .filter(c.quad == "S")
    .filter(c.hh_income_median > 80_000)
)
```

For each census division, compute the average median household income and the number of metros in that division.

```{python}
(
    metro
    .group_by(c.division)
    .agg(
        hh_income_mean = c.hh_income_median.mean(),
        count = pl.len()
    )
)
```

Find the most populous metro area in each quadrant of the country.

```{python}
(
    metro
    .sort(c.pop, descending=True)
    .group_by(c.quad)
    .head(1)
)
```

The population in our dataset is given in millions. Create a new column that shows the population in thousands instead.

```{python}
(
    metro
    .with_columns(
        pop_thousands = c.pop * 1_000
    )
)
```

Create a new column that computes the annual rent for a one-bedroom apartment (the current rent column shows monthly rent).

```{python}
(
    metro
    .with_columns(
        rent_1br_annual = c.rent_1br_median * 12
    )
)
```

The median household income is given as an exact figure, but it can be useful to round it. Create a new column that rounds the income to the nearest $10,000. Hint: Use the same integer division technique we used for computing decades from years.

```{python}
(
    metro
    .with_columns(
        income_rounded = (c.hh_income_median // 10_000 * 10_000)
    )
)
```

Now, count how many metro areas fall into each income bracket (rounded to the nearest $10,000).

```{python}
(
    metro
    .with_columns(
        income_rounded = (c.hh_income_median // 10_000 * 10_000)
    )
    .group_by(c.income_rounded)
    .agg(
        count = pl.len()
    )
    .sort(c.income_rounded)
)
```

For each census division, find the metro area with the lowest median rent. Sort the final result alphabetically by division name.

```{python}
(
    metro
    .sort(c.rent_1br_median)
    .group_by(c.division)
    .head(1)
    .sort(c.division)
)
```

Find the divisions that have more than 75 metro areas. Show the average home ownership rate for each of these divisions, sorted from highest to lowest ownership rate.

```{python}
(
    metro
    .group_by(c.division)
    .agg(
        percent_own_mean = c.percent_own.mean(),
        count = pl.len()
    )
    .filter(c.count > 75)
    .sort(c.percent_own_mean, descending=True)
)
```

For each division with more than 75 metro areas, show the name of the metro with the highest population density. Use `print_rows` to display all results.

```{python}
(
    metro
    .sort(c.density, descending=True)
    .group_by(c.division)
    .agg(
        densest_metro = c.name.first(),
        count = pl.len()
    )
    .filter(c.count > 75)
    .pipe(print_rows)
)
```
